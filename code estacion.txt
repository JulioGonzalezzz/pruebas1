#define SIM800L_IP5306_VERSION_20200811  
#define TINY_GSM_MODEM_SIM800            
#define TINY_GSM_RX_BUFFER 1024          

#include <TinyGsmClient.h>               
#include "esp_system.h"                  
#include "driver/rtc_io.h"               
#include <Wire.h>
#include <Adafruit_Sensor.h>
#include "Adafruit_BME680.h"             

#define SerialMon Serial                 
#define SerialAT  Serial1                

#define MODEM_RST            5           
#define MODEM_PWRKEY         4           
#define MODEM_POWER_ON       23          
#define MODEM_TX             27          
#define MODEM_RX             26          

#define LED_GPIO             13          
#define LED_ON               HIGH        
#define LED_OFF              LOW         

#define PIN_APN 35  // Pin para seleccionar APN
#define WAKEUP_PIN 34  // Pin para contar pulsos

const char serverClima[] = "clima.siucomgt.com";   
const char serverEstacion[] = "estacion.siucomgt.com";  
const int port = 80;  

const char pluviometro[] = "xxxx";         //2042                     
const char api_key[] = "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx";   

const char* apnTigo = "internet.tigo.gt";  //cambiar por el proveedor de apn #1
const char* apnClaro = "internet.ideasclaro"; //cambiar por el proveedor de apn #2
const char* apn;  
const char gprsUser[] = "";   
const char gprsPass[] = "";   
const char simPIN[] = "";     

TinyGsm modem(SerialAT);                 
TinyGsmClient client(modem);             
Adafruit_BME680 bme;                     
RTC_DATA_ATTR int pulseCount = 0;  // Guardar en memoria RTC para mantener los pulsos después del deep sleep

// Función de interrupción mejorada con filtro de rebotes
void IRAM_ATTR countPulse() {
    static unsigned long lastDebounceTime = 0;
    unsigned long interruptTime = millis();
    if (interruptTime - lastDebounceTime > 200) { // Filtrado de rebotes mejorado
        pulseCount++;
        lastDebounceTime = interruptTime;
    }
}

void setupModem() {
    pinMode(MODEM_RST, OUTPUT);
    digitalWrite(MODEM_RST, HIGH);

    pinMode(MODEM_PWRKEY, OUTPUT);
    pinMode(MODEM_POWER_ON, OUTPUT);
    digitalWrite(MODEM_POWER_ON, HIGH);
    digitalWrite(MODEM_PWRKEY, HIGH);
    delay(100);
    digitalWrite(MODEM_PWRKEY, LOW);
    delay(1000);
    digitalWrite(MODEM_PWRKEY, HIGH);

    pinMode(LED_GPIO, OUTPUT);
    digitalWrite(LED_GPIO, LED_OFF);
}

void setup() {
    SerialMon.begin(115200);
    setupModem();
    SerialAT.begin(115200, SERIAL_8N1, MODEM_RX, MODEM_TX);

    pinMode(PIN_APN, INPUT_PULLUP);
    delay(100);
    SerialMon.print("Estación: ");
    SerialMon.println(pluviometro);

    if (digitalRead(PIN_APN) == LOW) {
        SerialMon.println("APN seleccionado: Claro");
        apn = apnClaro;
    } else {
        SerialMon.println("APN seleccionado: Tigo");
        apn = apnTigo;
    }

    if (!bme.begin(0x76)) { //si SDO se conecta a GND la direccion es 0x76, ahora si SDO se conecta a VCC entonces la direccion es 0x77
                            //fisicamente es la resistencia R3 y R4 del módulo
                            //si la resistencia esta en la etiqueda R3 entonces la direccion es 0x77
                            //si la resistencia esta en la etiqueda R4 entonces la direccion es 0x76  
        SerialMon.println("No se encontró el sensor BME680");
        while (1);
    }

    bme.setTemperatureOversampling(BME680_OS_8X);
    bme.setHumidityOversampling(BME680_OS_2X);
    bme.setPressureOversampling(BME680_OS_4X);
    bme.setIIRFilterSize(BME680_FILTER_SIZE_3);
    bme.setGasHeater(320, 150);

    pinMode(WAKEUP_PIN, INPUT_PULLUP);
    attachInterrupt(digitalPinToInterrupt(WAKEUP_PIN), countPulse, FALLING);
}

bool connectToNetwork() {
    int retryCount = 0;
    const int maxRetries = 10;

    modem.restart();
    delay(5000);

    while (!modem.waitForNetwork(5000L)) {
        SerialMon.println("Red no disponible, reintentando...");
        retryCount++;
        if (retryCount >= maxRetries) {
            SerialMon.println("ERROR: No se pudo conectar a la red después de varios intentos.");
            return false;
        }
        delay(5000);
    }
    SerialMon.println("Red encontrada.");

    retryCount = 0;
    while (!modem.gprsConnect(apn, gprsUser, gprsPass)) {
        SerialMon.println("Conexión GPRS fallida, reintentando...");
        retryCount++;
        if (retryCount >= maxRetries) {
            SerialMon.println("ERROR: No se pudo conectar a GPRS después de varios intentos.");
            return false;
        }
        delay(5000);
    }
    SerialMon.println("Conexión GPRS establecida.");
    return true;
}

void sendData(const char* url, const char* host) {
    if (!connectToNetwork()) {
        SerialMon.println("Fallo en la conexión, entrando en modo de sueño...");
        return;
    }

    SerialMon.println("Conectando al servidor...");
    SerialMon.println("URL completa: " + String(url));

    if (!client.connect(host, port)) {
        SerialMon.println("Fallo en la conexión al servidor.");
        return;
    }
    SerialMon.println("Conectado al servidor.");

    client.print(String("GET ") + url + " HTTP/1.1\r\n" +
                 "Host: " + host + "\r\n" +
                 "User-Agent: ESP32/1.0\r\n" +
                 "Accept: */*\r\n" +
                 "Connection: close\r\n\r\n");

    while (client.connected()) {
        while (client.available()) {
            char c = client.read();
            SerialMon.print(c);
        }
    }
    SerialMon.println();
    client.stop();
    modem.gprsDisconnect();
    SerialMon.println("GPRS desconectado");
}

void loop() {
    esp_sleep_wakeup_cause_t wakeup_reason = esp_sleep_get_wakeup_cause();

    if (wakeup_reason == ESP_SLEEP_WAKEUP_EXT0) {
        SerialMon.println("Despertado por GPIO34, contando el primer pulso y esperando 10 segundos para contar más pulsos...");
        pulseCount++;
        delay(10000);
    }

    SerialMon.print("Total de pulsos acumulados: ");
    SerialMon.println(pulseCount);
    float cont_ml = pulseCount * 0.207;

    bme.performReading();
    float temperatura = bme.temperature;
    float humedad = bme.humidity;
    float presion = bme.pressure / 100.0;
    float gas_resistencia = bme.gas_resistance / 1000.0;

    if (wakeup_reason == ESP_SLEEP_WAKEUP_EXT0) {
        String fullUrl = String("/estacion/") + pluviometro + "/inserta.php?api_key=" + api_key + "&cont_ml=" + String(cont_ml);
        sendData(fullUrl.c_str(), serverEstacion);
        pulseCount = 0;
    } else {
        sendData((String("/clima/") + pluviometro + "/inserta.php?api_key=" + api_key + "&temperatura=" + String(temperatura) + "&humedad=" + String(humedad) + "&presion=" + String(presion) + "&gas_resistencia=" + String(gas_resistencia)).c_str(), serverClima);
    }

/*
esp_sleep_enable_timer_wakeup(tiempo_en_microsegundos);
1 segundo = 1,000,000 microsegundos
1 minuto = 60 * 1,000,000 microsegundos
5 minutos = 5 * 60 * 1,000,000 microsegundos
30 minutos = 60 * 60 * 1,000,000 microsegundos
*/
    esp_sleep_enable_timer_wakeup(30 * 60 * 1000000);
    esp_sleep_enable_ext0_wakeup(GPIO_NUM_34, 0);
    esp_deep_sleep_start();
}